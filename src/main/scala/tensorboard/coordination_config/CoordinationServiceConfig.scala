// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package tensorboard.coordination_config

/** Coordination service configuration parameters.
  * The system picks appropriate values for fields that are not set.
  *
  * @param serviceType
  *   Type of coordination service implementation to enable.
  *   For example, setting the service type as "standalone" starts a service
  *   instance on the leader task to provide the coordination services such as
  *   heartbeats and consistent key-value store.
  * @param serviceLeader
  *   Address where the coordination service instance is hosted.
  * @param enableHealthCheck
  *   Whether to enable the health check mechanism.
  * @param clusterRegisterTimeoutInMs
  *   Maximum wait time for all members in the cluster to be registered.
  * @param clusterRegisterWithBarrier
  *   Denotes if we should synchronize the agents' register attempts by blocking
  *   on a barrier. This is useful for synchronized restarts.
  * @param heartbeatTimeoutInMs
  *   Heartbeat timeout, if a task does not record heartbeat in this time
  *   window, it will be considered disconnected.
  *   Note: This is also used as a grace period to accept any heartbeats after
  *   the agent has disconnected, to account for the lag time between the service
  *   recording the state change and the agent stopping heartbeats.
  * @param shutdownBarrierTimeoutInMs
  *   Denotes how long to wait for all coordination agents to reach the barriers
  *   (after the first shutdown request) before disconnecting together. If
  *   set to 0, no barrier is imposed upon shutdown and each worker can
  *   disconnect individually.
  * @param agentDestructionWithoutShutdown
  *   If set, agents do not make an explicit Shutdown() call. Service will only
  *   find out about the disconnecte agent via stale heartbeats. Used for
  *   testing.
  * @param recoverableJobs
  *   The list of jobs which are recoverable. If a task in this list fails,
  *   it will not propagate error to other tasks.
  *   If empty, no jobs will be recoverable and every task failure will cause
  *   error propagation to other tasks.
  * @param allowNewIncarnationToReconnect
  *   If a task restarts with a new incarnation, we may allow it to reconnect
  *   silently. This is useful when we know that a task can immediately resume
  *   work upon re-connecting to the service.
  * @param forceDisable
  *   Disables coordination service.
  *   Some libraries enable coordination service by default even if the user did
  *   not specify any config. This field allows users to explicitly disable
  *   coordination service under all situations.
  * @param pollForErrorFromServiceAtStartup
  *   Use long polling to get error from coordination service as the error
  *   propagation mechanism.
  */
@SerialVersionUID(0L)
final case class CoordinationServiceConfig(
    serviceType: _root_.scala.Predef.String = "",
    serviceLeader: _root_.scala.Predef.String = "",
    enableHealthCheck: _root_.scala.Boolean = false,
    clusterRegisterTimeoutInMs: _root_.scala.Long = 0L,
    clusterRegisterWithBarrier: _root_.scala.Boolean = false,
    heartbeatTimeoutInMs: _root_.scala.Long = 0L,
    coordinatedJobList: _root_.scala.Seq[tensorboard.coordination_config.CoordinatedJob] = _root_.scala.Seq.empty,
    shutdownBarrierTimeoutInMs: _root_.scala.Long = 0L,
    agentDestructionWithoutShutdown: _root_.scala.Boolean = false,
    recoverableJobs: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    allowNewIncarnationToReconnect: _root_.scala.Boolean = false,
    forceDisable: _root_.scala.Boolean = false,
    pollForErrorFromServiceAtStartup: _root_.scala.Boolean = false,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[CoordinationServiceConfig] {
    @transient
    private[this] var __serializedSizeMemoized: _root_.scala.Int = 0
    private[this] def __computeSerializedSize(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = serviceType
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
        }
      };
      
      {
        val __value = serviceLeader
        if (!__value.isEmpty) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
        }
      };
      
      {
        val __value = enableHealthCheck
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(3, __value)
        }
      };
      
      {
        val __value = clusterRegisterTimeoutInMs
        if (__value != 0L) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(4, __value)
        }
      };
      
      {
        val __value = clusterRegisterWithBarrier
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(14, __value)
        }
      };
      
      {
        val __value = heartbeatTimeoutInMs
        if (__value != 0L) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(5, __value)
        }
      };
      coordinatedJobList.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      
      {
        val __value = shutdownBarrierTimeoutInMs
        if (__value != 0L) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(7, __value)
        }
      };
      
      {
        val __value = agentDestructionWithoutShutdown
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(8, __value)
        }
      };
      recoverableJobs.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(9, __value)
      }
      
      {
        val __value = allowNewIncarnationToReconnect
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(11, __value)
        }
      };
      
      {
        val __value = forceDisable
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(12, __value)
        }
      };
      
      {
        val __value = pollForErrorFromServiceAtStartup
        if (__value != false) {
          __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(13, __value)
        }
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var __size = __serializedSizeMemoized
      if (__size == 0) {
        __size = __computeSerializedSize() + 1
        __serializedSizeMemoized = __size
      }
      __size - 1
      
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = serviceType
        if (!__v.isEmpty) {
          _output__.writeString(1, __v)
        }
      };
      {
        val __v = serviceLeader
        if (!__v.isEmpty) {
          _output__.writeString(2, __v)
        }
      };
      {
        val __v = enableHealthCheck
        if (__v != false) {
          _output__.writeBool(3, __v)
        }
      };
      {
        val __v = clusterRegisterTimeoutInMs
        if (__v != 0L) {
          _output__.writeInt64(4, __v)
        }
      };
      {
        val __v = heartbeatTimeoutInMs
        if (__v != 0L) {
          _output__.writeInt64(5, __v)
        }
      };
      {
        val __v = shutdownBarrierTimeoutInMs
        if (__v != 0L) {
          _output__.writeInt64(7, __v)
        }
      };
      {
        val __v = agentDestructionWithoutShutdown
        if (__v != false) {
          _output__.writeBool(8, __v)
        }
      };
      recoverableJobs.foreach { __v =>
        val __m = __v
        _output__.writeString(9, __m)
      };
      coordinatedJobList.foreach { __v =>
        val __m = __v
        _output__.writeTag(10, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      {
        val __v = allowNewIncarnationToReconnect
        if (__v != false) {
          _output__.writeBool(11, __v)
        }
      };
      {
        val __v = forceDisable
        if (__v != false) {
          _output__.writeBool(12, __v)
        }
      };
      {
        val __v = pollForErrorFromServiceAtStartup
        if (__v != false) {
          _output__.writeBool(13, __v)
        }
      };
      {
        val __v = clusterRegisterWithBarrier
        if (__v != false) {
          _output__.writeBool(14, __v)
        }
      };
      unknownFields.writeTo(_output__)
    }
    def withServiceType(__v: _root_.scala.Predef.String): CoordinationServiceConfig = copy(serviceType = __v)
    def withServiceLeader(__v: _root_.scala.Predef.String): CoordinationServiceConfig = copy(serviceLeader = __v)
    def withEnableHealthCheck(__v: _root_.scala.Boolean): CoordinationServiceConfig = copy(enableHealthCheck = __v)
    def withClusterRegisterTimeoutInMs(__v: _root_.scala.Long): CoordinationServiceConfig = copy(clusterRegisterTimeoutInMs = __v)
    def withClusterRegisterWithBarrier(__v: _root_.scala.Boolean): CoordinationServiceConfig = copy(clusterRegisterWithBarrier = __v)
    def withHeartbeatTimeoutInMs(__v: _root_.scala.Long): CoordinationServiceConfig = copy(heartbeatTimeoutInMs = __v)
    def clearCoordinatedJobList = copy(coordinatedJobList = _root_.scala.Seq.empty)
    def addCoordinatedJobList(__vs: tensorboard.coordination_config.CoordinatedJob *): CoordinationServiceConfig = addAllCoordinatedJobList(__vs)
    def addAllCoordinatedJobList(__vs: Iterable[tensorboard.coordination_config.CoordinatedJob]): CoordinationServiceConfig = copy(coordinatedJobList = coordinatedJobList ++ __vs)
    def withCoordinatedJobList(__v: _root_.scala.Seq[tensorboard.coordination_config.CoordinatedJob]): CoordinationServiceConfig = copy(coordinatedJobList = __v)
    def withShutdownBarrierTimeoutInMs(__v: _root_.scala.Long): CoordinationServiceConfig = copy(shutdownBarrierTimeoutInMs = __v)
    def withAgentDestructionWithoutShutdown(__v: _root_.scala.Boolean): CoordinationServiceConfig = copy(agentDestructionWithoutShutdown = __v)
    def clearRecoverableJobs = copy(recoverableJobs = _root_.scala.Seq.empty)
    def addRecoverableJobs(__vs: _root_.scala.Predef.String *): CoordinationServiceConfig = addAllRecoverableJobs(__vs)
    def addAllRecoverableJobs(__vs: Iterable[_root_.scala.Predef.String]): CoordinationServiceConfig = copy(recoverableJobs = recoverableJobs ++ __vs)
    def withRecoverableJobs(__v: _root_.scala.Seq[_root_.scala.Predef.String]): CoordinationServiceConfig = copy(recoverableJobs = __v)
    def withAllowNewIncarnationToReconnect(__v: _root_.scala.Boolean): CoordinationServiceConfig = copy(allowNewIncarnationToReconnect = __v)
    def withForceDisable(__v: _root_.scala.Boolean): CoordinationServiceConfig = copy(forceDisable = __v)
    def withPollForErrorFromServiceAtStartup(__v: _root_.scala.Boolean): CoordinationServiceConfig = copy(pollForErrorFromServiceAtStartup = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => {
          val __t = serviceType
          if (__t != "") __t else null
        }
        case 2 => {
          val __t = serviceLeader
          if (__t != "") __t else null
        }
        case 3 => {
          val __t = enableHealthCheck
          if (__t != false) __t else null
        }
        case 4 => {
          val __t = clusterRegisterTimeoutInMs
          if (__t != 0L) __t else null
        }
        case 14 => {
          val __t = clusterRegisterWithBarrier
          if (__t != false) __t else null
        }
        case 5 => {
          val __t = heartbeatTimeoutInMs
          if (__t != 0L) __t else null
        }
        case 10 => coordinatedJobList
        case 7 => {
          val __t = shutdownBarrierTimeoutInMs
          if (__t != 0L) __t else null
        }
        case 8 => {
          val __t = agentDestructionWithoutShutdown
          if (__t != false) __t else null
        }
        case 9 => recoverableJobs
        case 11 => {
          val __t = allowNewIncarnationToReconnect
          if (__t != false) __t else null
        }
        case 12 => {
          val __t = forceDisable
          if (__t != false) __t else null
        }
        case 13 => {
          val __t = pollForErrorFromServiceAtStartup
          if (__t != false) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PString(serviceType)
        case 2 => _root_.scalapb.descriptors.PString(serviceLeader)
        case 3 => _root_.scalapb.descriptors.PBoolean(enableHealthCheck)
        case 4 => _root_.scalapb.descriptors.PLong(clusterRegisterTimeoutInMs)
        case 14 => _root_.scalapb.descriptors.PBoolean(clusterRegisterWithBarrier)
        case 5 => _root_.scalapb.descriptors.PLong(heartbeatTimeoutInMs)
        case 10 => _root_.scalapb.descriptors.PRepeated(coordinatedJobList.iterator.map(_.toPMessage).toVector)
        case 7 => _root_.scalapb.descriptors.PLong(shutdownBarrierTimeoutInMs)
        case 8 => _root_.scalapb.descriptors.PBoolean(agentDestructionWithoutShutdown)
        case 9 => _root_.scalapb.descriptors.PRepeated(recoverableJobs.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 11 => _root_.scalapb.descriptors.PBoolean(allowNewIncarnationToReconnect)
        case 12 => _root_.scalapb.descriptors.PBoolean(forceDisable)
        case 13 => _root_.scalapb.descriptors.PBoolean(pollForErrorFromServiceAtStartup)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion: tensorboard.coordination_config.CoordinationServiceConfig.type = tensorboard.coordination_config.CoordinationServiceConfig
    // @@protoc_insertion_point(GeneratedMessage[tensorboard.CoordinationServiceConfig])
}

object CoordinationServiceConfig extends scalapb.GeneratedMessageCompanion[tensorboard.coordination_config.CoordinationServiceConfig] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[tensorboard.coordination_config.CoordinationServiceConfig] = this
  def parseFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): tensorboard.coordination_config.CoordinationServiceConfig = {
    var __serviceType: _root_.scala.Predef.String = ""
    var __serviceLeader: _root_.scala.Predef.String = ""
    var __enableHealthCheck: _root_.scala.Boolean = false
    var __clusterRegisterTimeoutInMs: _root_.scala.Long = 0L
    var __clusterRegisterWithBarrier: _root_.scala.Boolean = false
    var __heartbeatTimeoutInMs: _root_.scala.Long = 0L
    val __coordinatedJobList: _root_.scala.collection.immutable.VectorBuilder[tensorboard.coordination_config.CoordinatedJob] = new _root_.scala.collection.immutable.VectorBuilder[tensorboard.coordination_config.CoordinatedJob]
    var __shutdownBarrierTimeoutInMs: _root_.scala.Long = 0L
    var __agentDestructionWithoutShutdown: _root_.scala.Boolean = false
    val __recoverableJobs: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String]
    var __allowNewIncarnationToReconnect: _root_.scala.Boolean = false
    var __forceDisable: _root_.scala.Boolean = false
    var __pollForErrorFromServiceAtStartup: _root_.scala.Boolean = false
    var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder = null
    var _done__ = false
    while (!_done__) {
      val _tag__ = _input__.readTag()
      _tag__ match {
        case 0 => _done__ = true
        case 10 =>
          __serviceType = _input__.readStringRequireUtf8()
        case 18 =>
          __serviceLeader = _input__.readStringRequireUtf8()
        case 24 =>
          __enableHealthCheck = _input__.readBool()
        case 32 =>
          __clusterRegisterTimeoutInMs = _input__.readInt64()
        case 112 =>
          __clusterRegisterWithBarrier = _input__.readBool()
        case 40 =>
          __heartbeatTimeoutInMs = _input__.readInt64()
        case 82 =>
          __coordinatedJobList += _root_.scalapb.LiteParser.readMessage[tensorboard.coordination_config.CoordinatedJob](_input__)
        case 56 =>
          __shutdownBarrierTimeoutInMs = _input__.readInt64()
        case 64 =>
          __agentDestructionWithoutShutdown = _input__.readBool()
        case 74 =>
          __recoverableJobs += _input__.readStringRequireUtf8()
        case 88 =>
          __allowNewIncarnationToReconnect = _input__.readBool()
        case 96 =>
          __forceDisable = _input__.readBool()
        case 104 =>
          __pollForErrorFromServiceAtStartup = _input__.readBool()
        case tag =>
          if (_unknownFields__ == null) {
            _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
          }
          _unknownFields__.parseField(tag, _input__)
      }
    }
    tensorboard.coordination_config.CoordinationServiceConfig(
        serviceType = __serviceType,
        serviceLeader = __serviceLeader,
        enableHealthCheck = __enableHealthCheck,
        clusterRegisterTimeoutInMs = __clusterRegisterTimeoutInMs,
        clusterRegisterWithBarrier = __clusterRegisterWithBarrier,
        heartbeatTimeoutInMs = __heartbeatTimeoutInMs,
        coordinatedJobList = __coordinatedJobList.result(),
        shutdownBarrierTimeoutInMs = __shutdownBarrierTimeoutInMs,
        agentDestructionWithoutShutdown = __agentDestructionWithoutShutdown,
        recoverableJobs = __recoverableJobs.result(),
        allowNewIncarnationToReconnect = __allowNewIncarnationToReconnect,
        forceDisable = __forceDisable,
        pollForErrorFromServiceAtStartup = __pollForErrorFromServiceAtStartup,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[tensorboard.coordination_config.CoordinationServiceConfig] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage eq scalaDescriptor), "FieldDescriptor does not match message type.")
      tensorboard.coordination_config.CoordinationServiceConfig(
        serviceType = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        serviceLeader = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Predef.String]).getOrElse(""),
        enableHealthCheck = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        clusterRegisterTimeoutInMs = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        clusterRegisterWithBarrier = __fieldsMap.get(scalaDescriptor.findFieldByNumber(14).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        heartbeatTimeoutInMs = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        coordinatedJobList = __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).map(_.as[_root_.scala.Seq[tensorboard.coordination_config.CoordinatedJob]]).getOrElse(_root_.scala.Seq.empty),
        shutdownBarrierTimeoutInMs = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        agentDestructionWithoutShutdown = __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        recoverableJobs = __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        allowNewIncarnationToReconnect = __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        forceDisable = __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).map(_.as[_root_.scala.Boolean]).getOrElse(false),
        pollForErrorFromServiceAtStartup = __fieldsMap.get(scalaDescriptor.findFieldByNumber(13).get).map(_.as[_root_.scala.Boolean]).getOrElse(false)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = tensorboard.coordination_config.CoordinationConfigProto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = tensorboard.coordination_config.CoordinationConfigProto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[?]= {
    var __out: _root_.scalapb.GeneratedMessageCompanion[?]= null
    (__number: @_root_.scala.unchecked) match {
      case 10 => __out = tensorboard.coordination_config.CoordinatedJob
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[? <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[?]= throw new MatchError(__fieldNumber)
  lazy val defaultInstance = tensorboard.coordination_config.CoordinationServiceConfig(
    serviceType = "",
    serviceLeader = "",
    enableHealthCheck = false,
    clusterRegisterTimeoutInMs = 0L,
    clusterRegisterWithBarrier = false,
    heartbeatTimeoutInMs = 0L,
    coordinatedJobList = _root_.scala.Seq.empty,
    shutdownBarrierTimeoutInMs = 0L,
    agentDestructionWithoutShutdown = false,
    recoverableJobs = _root_.scala.Seq.empty,
    allowNewIncarnationToReconnect = false,
    forceDisable = false,
    pollForErrorFromServiceAtStartup = false
  )
  implicit class CoordinationServiceConfigLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, tensorboard.coordination_config.CoordinationServiceConfig]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, tensorboard.coordination_config.CoordinationServiceConfig](_l) {
    def serviceType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.serviceType)((c_, f_) => c_.copy(serviceType = f_))
    def serviceLeader: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.serviceLeader)((c_, f_) => c_.copy(serviceLeader = f_))
    def enableHealthCheck: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.enableHealthCheck)((c_, f_) => c_.copy(enableHealthCheck = f_))
    def clusterRegisterTimeoutInMs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.clusterRegisterTimeoutInMs)((c_, f_) => c_.copy(clusterRegisterTimeoutInMs = f_))
    def clusterRegisterWithBarrier: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.clusterRegisterWithBarrier)((c_, f_) => c_.copy(clusterRegisterWithBarrier = f_))
    def heartbeatTimeoutInMs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heartbeatTimeoutInMs)((c_, f_) => c_.copy(heartbeatTimeoutInMs = f_))
    def coordinatedJobList: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[tensorboard.coordination_config.CoordinatedJob]] = field(_.coordinatedJobList)((c_, f_) => c_.copy(coordinatedJobList = f_))
    def shutdownBarrierTimeoutInMs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.shutdownBarrierTimeoutInMs)((c_, f_) => c_.copy(shutdownBarrierTimeoutInMs = f_))
    def agentDestructionWithoutShutdown: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.agentDestructionWithoutShutdown)((c_, f_) => c_.copy(agentDestructionWithoutShutdown = f_))
    def recoverableJobs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.recoverableJobs)((c_, f_) => c_.copy(recoverableJobs = f_))
    def allowNewIncarnationToReconnect: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.allowNewIncarnationToReconnect)((c_, f_) => c_.copy(allowNewIncarnationToReconnect = f_))
    def forceDisable: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.forceDisable)((c_, f_) => c_.copy(forceDisable = f_))
    def pollForErrorFromServiceAtStartup: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.pollForErrorFromServiceAtStartup)((c_, f_) => c_.copy(pollForErrorFromServiceAtStartup = f_))
  }
  final val SERVICE_TYPE_FIELD_NUMBER = 1
  final val SERVICE_LEADER_FIELD_NUMBER = 2
  final val ENABLE_HEALTH_CHECK_FIELD_NUMBER = 3
  final val CLUSTER_REGISTER_TIMEOUT_IN_MS_FIELD_NUMBER = 4
  final val CLUSTER_REGISTER_WITH_BARRIER_FIELD_NUMBER = 14
  final val HEARTBEAT_TIMEOUT_IN_MS_FIELD_NUMBER = 5
  final val COORDINATED_JOB_LIST_FIELD_NUMBER = 10
  final val SHUTDOWN_BARRIER_TIMEOUT_IN_MS_FIELD_NUMBER = 7
  final val AGENT_DESTRUCTION_WITHOUT_SHUTDOWN_FIELD_NUMBER = 8
  final val RECOVERABLE_JOBS_FIELD_NUMBER = 9
  final val ALLOW_NEW_INCARNATION_TO_RECONNECT_FIELD_NUMBER = 11
  final val FORCE_DISABLE_FIELD_NUMBER = 12
  final val POLL_FOR_ERROR_FROM_SERVICE_AT_STARTUP_FIELD_NUMBER = 13
  def of(
    serviceType: _root_.scala.Predef.String,
    serviceLeader: _root_.scala.Predef.String,
    enableHealthCheck: _root_.scala.Boolean,
    clusterRegisterTimeoutInMs: _root_.scala.Long,
    clusterRegisterWithBarrier: _root_.scala.Boolean,
    heartbeatTimeoutInMs: _root_.scala.Long,
    coordinatedJobList: _root_.scala.Seq[tensorboard.coordination_config.CoordinatedJob],
    shutdownBarrierTimeoutInMs: _root_.scala.Long,
    agentDestructionWithoutShutdown: _root_.scala.Boolean,
    recoverableJobs: _root_.scala.Seq[_root_.scala.Predef.String],
    allowNewIncarnationToReconnect: _root_.scala.Boolean,
    forceDisable: _root_.scala.Boolean,
    pollForErrorFromServiceAtStartup: _root_.scala.Boolean
  ): _root_.tensorboard.coordination_config.CoordinationServiceConfig = _root_.tensorboard.coordination_config.CoordinationServiceConfig(
    serviceType,
    serviceLeader,
    enableHealthCheck,
    clusterRegisterTimeoutInMs,
    clusterRegisterWithBarrier,
    heartbeatTimeoutInMs,
    coordinatedJobList,
    shutdownBarrierTimeoutInMs,
    agentDestructionWithoutShutdown,
    recoverableJobs,
    allowNewIncarnationToReconnect,
    forceDisable,
    pollForErrorFromServiceAtStartup
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[tensorboard.CoordinationServiceConfig])
}

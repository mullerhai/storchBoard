// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package tensorflow.framework.full_type

import tensorflow.framework.full_type

/** DISABLED.IfChange
  * Experimental. Represents the complete type information of a TensorFlow value.
  */
sealed abstract class FullTypeId(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
  type EnumType = FullTypeId
  type RecognizedType = FullTypeId.Recognized
  def isTftUnset: _root_.scala.Boolean = false
  def isTftVar: _root_.scala.Boolean = false
  def isTftAny: _root_.scala.Boolean = false
  def isTftProduct: _root_.scala.Boolean = false
  def isTftNamed: _root_.scala.Boolean = false
  def isTftForEach: _root_.scala.Boolean = false
  def isTftCallable: _root_.scala.Boolean = false
  def isTftTensor: _root_.scala.Boolean = false
  def isTftArray: _root_.scala.Boolean = false
  def isTftOptional: _root_.scala.Boolean = false
  def isTftLiteral: _root_.scala.Boolean = false
  def isTftEncoded: _root_.scala.Boolean = false
  def isTftShapeTensor: _root_.scala.Boolean = false
  def isTftBool: _root_.scala.Boolean = false
  def isTftUint8: _root_.scala.Boolean = false
  def isTftUint16: _root_.scala.Boolean = false
  def isTftUint32: _root_.scala.Boolean = false
  def isTftUint64: _root_.scala.Boolean = false
  def isTftInt8: _root_.scala.Boolean = false
  def isTftInt16: _root_.scala.Boolean = false
  def isTftInt32: _root_.scala.Boolean = false
  def isTftInt64: _root_.scala.Boolean = false
  def isTftHalf: _root_.scala.Boolean = false
  def isTftFloat: _root_.scala.Boolean = false
  def isTftDouble: _root_.scala.Boolean = false
  def isTftBfloat16: _root_.scala.Boolean = false
  def isTftComplex64: _root_.scala.Boolean = false
  def isTftComplex128: _root_.scala.Boolean = false
  def isTftString: _root_.scala.Boolean = false
  def isTftDataset: _root_.scala.Boolean = false
  def isTftRagged: _root_.scala.Boolean = false
  def isTftIterator: _root_.scala.Boolean = false
  def isTftMutexLock: _root_.scala.Boolean = false
  def isTftLegacyVariant: _root_.scala.Boolean = false
  def companion: _root_.scalapb.GeneratedEnumCompanion[FullTypeId] = full_type.FullTypeId
  final def asRecognized: _root_.scala.Option[FullTypeId.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[FullTypeId.Recognized])
}

object FullTypeId extends _root_.scalapb.GeneratedEnumCompanion[FullTypeId] {
  sealed trait Recognized extends FullTypeId
  implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[FullTypeId] = this
  
  /** The default represents an uninitialized values.
    */
  @SerialVersionUID(0L)
  case object TFT_UNSET extends FullTypeId(0) with FullTypeId.Recognized {
    val index = 0
    val name = "TFT_UNSET"
    override def isTftUnset: _root_.scala.Boolean = true
  }
  
  /** Type variables may serve as placeholder for any other type ID in type
    * templates.
    *
    * Examples:
    *   TFT_DATASET[TFT_VAR["T"]] is a Dataset returning a type indicated by "T".
    *   TFT_TENSOR[TFT_VAR["T"]] is a Tensor of n element type indicated by "T".
    *   TFT_TENSOR[TFT_VAR["T"]], TFT_TENSOR[TFT_VAR["T"]] are two tensors of
    *     identical element types.
    *   TFT_TENSOR[TFT_VAR["P"]], TFT_TENSOR[TFT_VAR["Q"]] are two tensors of
    *     independent element types.
    */
  @SerialVersionUID(0L)
  case object TFT_VAR extends FullTypeId(1) with FullTypeId.Recognized {
    val index = 1
    val name = "TFT_VAR"
    override def isTftVar: _root_.scala.Boolean = true
  }
  
  /** Wildcard type. Describes a parameter of unknown type. In TensorFlow, that
    * can mean either a "Top" type (accepts any type), or a dynamically typed
    * object whose type is unknown in context.
    * Important: "unknown" does not necessarily mean undeterminable!
    */
  @SerialVersionUID(0L)
  case object TFT_ANY extends FullTypeId(2) with FullTypeId.Recognized {
    val index = 2
    val name = "TFT_ANY"
    override def isTftAny: _root_.scala.Boolean = true
  }
  
  /** The algebraic product type. This is an algebraic type that may be used just
    * for logical grouping. Not to confused with TFT_TUPLE which describes a
    * concrete object of several elements.
    *
    * Example:
    *   TFT_DATASET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]]]
    *     is a Dataset producing two tensors, an integer one and a float one.
    */
  @SerialVersionUID(0L)
  case object TFT_PRODUCT extends FullTypeId(3) with FullTypeId.Recognized {
    val index = 3
    val name = "TFT_PRODUCT"
    override def isTftProduct: _root_.scala.Boolean = true
  }
  
  /** Represents a named field, with the name stored in the attribute.
    *
    * Parametrization:
    *   TFT_NAMED[&lt;type&gt;]{&lt;name&gt;}
    *   * &lt;type&gt; is the type of the field
    *   * &lt;name&gt; is the field name, as string (thpugh can theoretically be an int
    *     as well)
    *
    * Example:
    *   TFT_RECORD[
    *     TFT_NAMED[TFT_TENSOR[TFT_INT32]]{'foo'},
    *     TFT_NAMED[TFT_TENSOR[TFT_FLOAT32]]{'bar'},
    *   ]
    *     is a structure with two fields, an int tensor "foo" and a float tensor
    *     "bar".
    */
  @SerialVersionUID(0L)
  case object TFT_NAMED extends FullTypeId(4) with FullTypeId.Recognized {
    val index = 4
    val name = "TFT_NAMED"
    override def isTftNamed: _root_.scala.Boolean = true
  }
  
  /** Template definition. Expands the variables by repeating a template as
    * arguments of container.
    *
    * Parametrization:
    *   TFT_FOR_EACH[&lt;container_type&gt;, &lt;template&gt;, &lt;expansions&gt;]
    *   * &lt;container_type&gt; is the type of the container that the template will be
    *     expanded into
    *   * &lt;template&gt; is any type definition that potentially contains type
    *     variables
    *   * &lt;expansions&gt; is a TFT_VAR and may include more types in the future
    *
    * Example:
    *   TFT_FOR_EACH[
    *         TFT_PRODUCT,
    *         TFT_TENSOR[TFT_VAR["t"]],
    *         TFT_VAR["t"]
    *     ]
    *     will substitute a T = TFT_INT32 to TFT_PRODUCT[TFT_TENSOR[TFT_INT32]]
    *     and a T = (TFT_INT32, TFT_INT64) to
    *     TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_INT64]].
    */
  @SerialVersionUID(0L)
  case object TFT_FOR_EACH extends FullTypeId(20) with FullTypeId.Recognized {
    val index = 5
    val name = "TFT_FOR_EACH"
    override def isTftForEach: _root_.scala.Boolean = true
  }
  
  /** Callable types describe functions and ops.
    *
    * Parametrization:
    *   TFT_CALLABLE[&lt;arg type&gt;, &lt;return type&gt;]
    *   * &lt;arg type&gt; is the type of the arguments; TFT_PRODUCT represents
    *   multiple
    *     arguments.
    *   * &lt;return type&gt; is the return type; TFT_PRODUCT represents multiple
    *     return values (that means that callables returning multiple things
    *     don't necessarily return a single tuple).
    *
    * Example:
    *   TFT_CALLABLE[
    *     TFT_ANY,
    *     TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]],
    *   ]
    *     is a callable with unspecified (for now) input arguments, and
    *     two return values of type tensor.
    */
  @SerialVersionUID(0L)
  case object TFT_CALLABLE extends FullTypeId(100) with FullTypeId.Recognized {
    val index = 6
    val name = "TFT_CALLABLE"
    override def isTftCallable: _root_.scala.Boolean = true
  }
  
  /** The usual Tensor. This is a parametric type.
    *
    * Parametrization:
    *   TFT_TENSOR[&lt;element type&gt;, &lt;shape type&gt;]
    *   * &lt;element type&gt; is currently limited to one of the element types
    *     defined below.
    *   * &lt;shape type&gt; is not yet defined, and may only be TFT_UNKNOWN for now.
    *
    * A TFT_SHAPE type will be defined in the future.
    *
    * Example:
    *   TFT_TENSOR[TFT_INT32, TFT_UNKNOWN]
    *     is a Tensor of int32 element type and unknown shape.
    *
    * TODO(mdan): Define TFT_SHAPE and add more examples.
    */
  @SerialVersionUID(0L)
  case object TFT_TENSOR extends FullTypeId(1000) with FullTypeId.Recognized {
    val index = 7
    val name = "TFT_TENSOR"
    override def isTftTensor: _root_.scala.Boolean = true
  }
  
  /** Array (or tensorflow::TensorList in the variant type registry).
    * Note: this is not to be confused with the deprecated `TensorArray*` ops
    * which are not supported by FullType.
    * This type represents a random-access list whose elements can be
    * described by a single type. Although immutable, Array is expected to
    * support efficient mutation semantics (i.e. element update) in the
    * user-facing API.
    * The element type may be generic or even TFT_ANY for a heterogenous list.
    *
    * Parametrization:
    *   TFT_ARRAY[&lt;element type&gt;]
    *   * &lt;element type&gt; may be any concrete type.
    *
    * Examples:
    *   TFT_ARRAY[TFT_TENSOR[TFT_INT32]] is a TensorArray holding int32 Tensors
    *     of any shape.
    *   TFT_ARRAY[TFT_TENSOR[TFT_UNKNOWN]] is a TensorArray holding Tensors of
    *     mixed element types.
    *   TFT_ARRAY[TFT_UNKNOWN] is a TensorArray holding any element type.
    *   TFT_ARRAY[] is equivalent to TFT_ARRAY[TFT_UNKNOWN].
    *   TFT_ARRAY[TFT_ARRAY[]] is an array or arrays (of unknown types).
    */
  @SerialVersionUID(0L)
  case object TFT_ARRAY extends FullTypeId(1001) with FullTypeId.Recognized {
    val index = 8
    val name = "TFT_ARRAY"
    override def isTftArray: _root_.scala.Boolean = true
  }
  
  /** Optional (or tensorflow::OptionalVariant in the variant type registry).
    * This type represents a value that may either hold an element of a single
    * specified type, or nothing at all.
    *
    * Parametrization:
    *   TFT_OPTIONAL[&lt;element type&gt;]
    *   * &lt;element type&gt; may be any concrete type.
    *
    * Examples:
    *   TFT_OPTIONAL[TFT_TENSOR[TFT_INT32]] is an Optional holding an int32
    *     Tensor of any shape.
    */
  @SerialVersionUID(0L)
  case object TFT_OPTIONAL extends FullTypeId(1002) with FullTypeId.Recognized {
    val index = 9
    val name = "TFT_OPTIONAL"
    override def isTftOptional: _root_.scala.Boolean = true
  }
  
  /** Literal types describe compile-time constant values.
    * Literal types may also participate in dependent types.
    *
    * Parametrization:
    *   TFT_LITERAL[&lt;value type&gt;]{&lt;value&gt;}
    *   * &lt;value type&gt; may be any concrete type compatible that can hold &lt;value&gt;
    *   * &lt;value&gt; is the type's attribute, and holds the actual literal value
    *
    * Examples:
    *   TFT_LITERAL[TFT_INT32]{1} is the compile-time constant 1.
    */
  @SerialVersionUID(0L)
  case object TFT_LITERAL extends FullTypeId(1003) with FullTypeId.Recognized {
    val index = 10
    val name = "TFT_LITERAL"
    override def isTftLiteral: _root_.scala.Boolean = true
  }
  
  /** Encoding types describe a value of a certain type, encoded as a different
    * type.
    *
    * Parametrization:
    *   TFT_ENCODED[&lt;encoded type&gt;, &lt;encoding type&gt;]
    *   * &lt;encoded type&gt; may be any type
    *   * &lt;encoding type&gt; may be any type
    *
    * Examples:
    *   TFT_ENCODING[TFT_INT32, TFT_STRING] is an integer encoded as string.
    */
  @SerialVersionUID(0L)
  case object TFT_ENCODED extends FullTypeId(1004) with FullTypeId.Recognized {
    val index = 11
    val name = "TFT_ENCODED"
    override def isTftEncoded: _root_.scala.Boolean = true
  }
  
  /** The type of "shape tensors" where the runtime value is the shape of
    * some tensor(s), i.e. the output of tf.shape.
    * Shape tensors have special, host-only placement, in contrast to
    * TFT_TENSOR[TFT_INT32] which is the type of a normal numeric tensor
    * with no special placement.
    *
    * Examples:
    *   TFT_SHAPE_TENSOR[TFT_INT32] is the most common
    *   TFT_SHAPE_TENSOR[TFT_INT64] is also allowed
    */
  @SerialVersionUID(0L)
  case object TFT_SHAPE_TENSOR extends FullTypeId(1005) with FullTypeId.Recognized {
    val index = 12
    val name = "TFT_SHAPE_TENSOR"
    override def isTftShapeTensor: _root_.scala.Boolean = true
  }
  
  /** The bool element type.
    * TODO(mdan): Quantized types, legacy representations (e.g. ref)
    */
  @SerialVersionUID(0L)
  case object TFT_BOOL extends FullTypeId(200) with FullTypeId.Recognized {
    val index = 13
    val name = "TFT_BOOL"
    override def isTftBool: _root_.scala.Boolean = true
  }
  
  /** Integer element types.
    */
  @SerialVersionUID(0L)
  case object TFT_UINT8 extends FullTypeId(201) with FullTypeId.Recognized {
    val index = 14
    val name = "TFT_UINT8"
    override def isTftUint8: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_UINT16 extends FullTypeId(202) with FullTypeId.Recognized {
    val index = 15
    val name = "TFT_UINT16"
    override def isTftUint16: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_UINT32 extends FullTypeId(203) with FullTypeId.Recognized {
    val index = 16
    val name = "TFT_UINT32"
    override def isTftUint32: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_UINT64 extends FullTypeId(204) with FullTypeId.Recognized {
    val index = 17
    val name = "TFT_UINT64"
    override def isTftUint64: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_INT8 extends FullTypeId(205) with FullTypeId.Recognized {
    val index = 18
    val name = "TFT_INT8"
    override def isTftInt8: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_INT16 extends FullTypeId(206) with FullTypeId.Recognized {
    val index = 19
    val name = "TFT_INT16"
    override def isTftInt16: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_INT32 extends FullTypeId(207) with FullTypeId.Recognized {
    val index = 20
    val name = "TFT_INT32"
    override def isTftInt32: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_INT64 extends FullTypeId(208) with FullTypeId.Recognized {
    val index = 21
    val name = "TFT_INT64"
    override def isTftInt64: _root_.scala.Boolean = true
  }
  
  /** Floating-point element types.
    */
  @SerialVersionUID(0L)
  case object TFT_HALF extends FullTypeId(209) with FullTypeId.Recognized {
    val index = 22
    val name = "TFT_HALF"
    override def isTftHalf: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_FLOAT extends FullTypeId(210) with FullTypeId.Recognized {
    val index = 23
    val name = "TFT_FLOAT"
    override def isTftFloat: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_DOUBLE extends FullTypeId(211) with FullTypeId.Recognized {
    val index = 24
    val name = "TFT_DOUBLE"
    override def isTftDouble: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_BFLOAT16 extends FullTypeId(215) with FullTypeId.Recognized {
    val index = 25
    val name = "TFT_BFLOAT16"
    override def isTftBfloat16: _root_.scala.Boolean = true
  }
  
  /** Complex element types.
    * TODO(mdan): Represent as TFT_COMPLEX[TFT_DOUBLE] instead?
    */
  @SerialVersionUID(0L)
  case object TFT_COMPLEX64 extends FullTypeId(212) with FullTypeId.Recognized {
    val index = 26
    val name = "TFT_COMPLEX64"
    override def isTftComplex64: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  case object TFT_COMPLEX128 extends FullTypeId(213) with FullTypeId.Recognized {
    val index = 27
    val name = "TFT_COMPLEX128"
    override def isTftComplex128: _root_.scala.Boolean = true
  }
  
  /** The string element type.
    */
  @SerialVersionUID(0L)
  case object TFT_STRING extends FullTypeId(214) with FullTypeId.Recognized {
    val index = 28
    val name = "TFT_STRING"
    override def isTftString: _root_.scala.Boolean = true
  }
  
  /** Datasets created by tf.data ops and APIs. Datasets have generator/iterable
    * semantics, that is, one can construct an iterator from them. Like
    * Array, they are considered to return elements that can be described
    * by a single type. Unlike Array, they do not support random access or
    * mutation, and can potentially produce an infinite number of elements.
    * A datasets can produce logical structures (e.g. multiple elements). This
    * is expressed using TFT_PRODUCT.
    *
    *
    * Parametrization: TFT_DATASET[&lt;element type&gt;].
    *   * &lt;element type&gt; may be a concrete type or a type symbol. It represents
    *     the data type of the elements produced by the dataset.
    *
    * Examples:
    *   TFT_DATSET[TFT_TENSOR[TFT_INT32]] is a Dataset producing single int32
    *     Tensors of unknown shape.
    *   TFT_DATSET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT32]] is
    *     a Dataset producing pairs of Tensors, one integer and one float.
    * Note: The high ID number is to prepare for the eventuality that Datasets
    * will be supported by user types in the future.
    */
  @SerialVersionUID(0L)
  case object TFT_DATASET extends FullTypeId(10102) with FullTypeId.Recognized {
    val index = 29
    val name = "TFT_DATASET"
    override def isTftDataset: _root_.scala.Boolean = true
  }
  
  /** A ragged tensor created by tf.ragged ops and APIs.
    *
    * Parametrization: TFT_RAGGED[&lt;element_type&gt;].
    */
  @SerialVersionUID(0L)
  case object TFT_RAGGED extends FullTypeId(10103) with FullTypeId.Recognized {
    val index = 30
    val name = "TFT_RAGGED"
    override def isTftRagged: _root_.scala.Boolean = true
  }
  
  /** Iterators created by tf.data ops and APIs. Very similar to Datasets, except
    * they are mutable.
    *
    *
    * Parametrization: TFT_ITERATOR[&lt;element type&gt;].
    *   * &lt;element type&gt; may be a concrete type or a type symbol. It represents
    *     the data type of the elements produced by the dataset.
    */
  @SerialVersionUID(0L)
  case object TFT_ITERATOR extends FullTypeId(10104) with FullTypeId.Recognized {
    val index = 31
    val name = "TFT_ITERATOR"
    override def isTftIterator: _root_.scala.Boolean = true
  }
  
  /** A mutex lock tensor, produced by tf.raw_ops.MutexLock.
    * Unlike strict execution models, where ownership of a lock is denoted by
    * "running after the lock has been acquired", in non-strict mode, lock
    * ownership is in the true sense: "the op argument representing the lock is
    * available".
    * Mutex locks are the dynamic counterpart of control dependencies.
    * TODO(mdan): Properly document this thing.
    *
    * Parametrization: TFT_MUTEX_LOCK[].
    */
  @SerialVersionUID(0L)
  case object TFT_MUTEX_LOCK extends FullTypeId(10202) with FullTypeId.Recognized {
    val index = 32
    val name = "TFT_MUTEX_LOCK"
    override def isTftMutexLock: _root_.scala.Boolean = true
  }
  
  /** The equivalent of a Tensor with DT_VARIANT dtype, kept here to simplify
    * translation. This type should not normally appear after type inference.
    * Note that LEGACY_VARIANT != ANY: TENSOR[INT32] is a subtype of ANY, but is
    * not a subtype of LEGACY_VARIANT.
    */
  @SerialVersionUID(0L)
  case object TFT_LEGACY_VARIANT extends FullTypeId(10203) with FullTypeId.Recognized {
    val index = 33
    val name = "TFT_LEGACY_VARIANT"
    override def isTftLegacyVariant: _root_.scala.Boolean = true
  }
  
  @SerialVersionUID(0L)
  final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends FullTypeId(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
  lazy val values: scala.collection.immutable.Seq[ValueType] = scala.collection.immutable.Seq(TFT_UNSET, TFT_VAR, TFT_ANY, TFT_PRODUCT, TFT_NAMED, TFT_FOR_EACH, TFT_CALLABLE, TFT_TENSOR, TFT_ARRAY, TFT_OPTIONAL, TFT_LITERAL, TFT_ENCODED, TFT_SHAPE_TENSOR, TFT_BOOL, TFT_UINT8, TFT_UINT16, TFT_UINT32, TFT_UINT64, TFT_INT8, TFT_INT16, TFT_INT32, TFT_INT64, TFT_HALF, TFT_FLOAT, TFT_DOUBLE, TFT_BFLOAT16, TFT_COMPLEX64, TFT_COMPLEX128, TFT_STRING, TFT_DATASET, TFT_RAGGED, TFT_ITERATOR, TFT_MUTEX_LOCK, TFT_LEGACY_VARIANT)
  def fromValue(__value: _root_.scala.Int): FullTypeId = __value match {
    case 0 => TFT_UNSET
    case 1 => TFT_VAR
    case 2 => TFT_ANY
    case 3 => TFT_PRODUCT
    case 4 => TFT_NAMED
    case 20 => TFT_FOR_EACH
    case 100 => TFT_CALLABLE
    case 200 => TFT_BOOL
    case 201 => TFT_UINT8
    case 202 => TFT_UINT16
    case 203 => TFT_UINT32
    case 204 => TFT_UINT64
    case 205 => TFT_INT8
    case 206 => TFT_INT16
    case 207 => TFT_INT32
    case 208 => TFT_INT64
    case 209 => TFT_HALF
    case 210 => TFT_FLOAT
    case 211 => TFT_DOUBLE
    case 212 => TFT_COMPLEX64
    case 213 => TFT_COMPLEX128
    case 214 => TFT_STRING
    case 215 => TFT_BFLOAT16
    case 1000 => TFT_TENSOR
    case 1001 => TFT_ARRAY
    case 1002 => TFT_OPTIONAL
    case 1003 => TFT_LITERAL
    case 1004 => TFT_ENCODED
    case 1005 => TFT_SHAPE_TENSOR
    case 10102 => TFT_DATASET
    case 10103 => TFT_RAGGED
    case 10104 => TFT_ITERATOR
    case 10202 => TFT_MUTEX_LOCK
    case 10203 => TFT_LEGACY_VARIANT
    case __other => Unrecognized(__other)
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = org.tensorflow.framework.full_type.FullTypeProto.javaDescriptor.getEnumTypes().get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = org.tensorflow.framework.full_type.FullTypeProto.scalaDescriptor.enums(0)
}